/**
 * Arduino Code Generator for No-Code Editor Blocks
 * 
 * This generator converts No-Code Editor blocks to Arduino C++ code.
 * Python code is still generated for display, but Arduino C++ is what gets uploaded.
 */

import type { PlacedBlock, BlockConnection } from "./block-types";
import { schemaData } from "./no-code-blocks";

/**
 * Generate Arduino C++ code from No-Code Editor blocks
 */
export function generateArduinoCodeFromBlocks(
  placedBlocks: PlacedBlock[],
  connections: BlockConnection[]
): string {
  if (placedBlocks.length === 0) {
    return `/*
 * Arduino Sketch - Generated by E-GROOTS No-Code Editor
 * No blocks added yet
 */

void setup() {
  // No setup required
}

void loop() {
  // No loop code
}`;
  }

  // Order all blocks by visual position (Y coordinate) first, then follow connections
  const orderedBlocks = orderBlocksByVisualPosition(placedBlocks, connections);
  
  // Track visited blocks
  const visited = new Set<string>();
  
  // Collect code sections
  const globalLines: string[] = [];
  const setupLines: string[] = [];
  const loopLines: string[] = [];
  const usedPins = new Set<number>();
  const addedSetupCode = new Set<string>();
  const addedGlobalCode = new Set<string>();

  // Generate code following the ordered sequence
  for (const block of orderedBlocks) {
    if (!visited.has(block.id)) {
      generateFromBlock(
        block,
        placedBlocks,
        connections,
        visited,
        globalLines,
        setupLines,
        loopLines,
        usedPins,
        addedSetupCode,
        addedGlobalCode,
        0,
        false // isNested = false (top-level blocks)
      );
    }
  }

  // Build final Arduino sketch
  const lines: string[] = [];
  
  lines.push("/*");
  lines.push(" * Arduino Sketch - Generated by E-GROOTS No-Code Editor");
  lines.push(" * Board: Arduino Nano");
  lines.push(" * Generated: " + new Date().toISOString());
  lines.push(" */");
  lines.push("");

  // Add global code
  if (globalLines.length > 0) {
    for (const line of globalLines) {
      lines.push(line);
    }
    lines.push("");
  }

  // Add setup function
  lines.push("void setup() {");
  if (setupLines.length === 0) {
    lines.push("  // No setup required");
  } else {
    for (const line of setupLines) {
      lines.push("  " + line);
    }
  }
  lines.push("}");
  lines.push("");

  // Add loop function
  lines.push("void loop() {");
  if (loopLines.length === 0) {
    lines.push("  // No loop code");
  } else {
    for (const line of loopLines) {
      lines.push("  " + line);
    }
  }
  lines.push("}");

  return lines.join("\n");
}

/**
 * Order blocks by visual position (Y coordinate), respecting connections
 * This ensures blocks appear in the order they're visually arranged
 */
function orderBlocksByVisualPosition(
  placedBlocks: PlacedBlock[],
  connections: BlockConnection[]
): PlacedBlock[] {
  // First, sort all blocks by Y position (top to bottom)
  const sortedByY = [...placedBlocks].sort((a, b) => {
    // Primary sort: Y position (top to bottom)
    if (a.y !== b.y) {
      return a.y - b.y;
    }
    // Secondary sort: X position (left to right) for blocks at same Y
    return a.x - b.x;
  });

  // Build a map of connections for quick lookup
  // Separate connections into: nesting (from loops/conditionals) and sequential (from regular blocks)
  const nestingConnectionMap = new Map<string, string[]>();
  const sequentialConnectionMap = new Map<string, string[]>();
  const blockMap = new Map(placedBlocks.map(b => [b.id, b]));
  
  for (const conn of connections) {
    const fromBlock = blockMap.get(conn.fromBlockId);
    const isNesting = fromBlock && shouldNestContent(fromBlock.blockId);
    
    if (isNesting) {
      // This is a nesting connection (loop/conditional to nested block)
      if (!nestingConnectionMap.has(conn.fromBlockId)) {
        nestingConnectionMap.set(conn.fromBlockId, []);
      }
      nestingConnectionMap.get(conn.fromBlockId)!.push(conn.toBlockId);
    } else {
      // This is a sequential connection (regular block to next block)
      if (!sequentialConnectionMap.has(conn.fromBlockId)) {
        sequentialConnectionMap.set(conn.fromBlockId, []);
      }
      sequentialConnectionMap.get(conn.fromBlockId)!.push(conn.toBlockId);
    }
  }

  // Build reverse map (what blocks point to this block) - only for sequential connections
  const reverseMap = new Map<string, string[]>();
  for (const conn of connections) {
    const fromBlock = blockMap.get(conn.fromBlockId);
    const isNesting = fromBlock && shouldNestContent(fromBlock.blockId);
    
    if (!isNesting) {
      // Only track reverse connections for sequential blocks
      if (!reverseMap.has(conn.toBlockId)) {
        reverseMap.set(conn.toBlockId, []);
      }
      reverseMap.get(conn.toBlockId)!.push(conn.fromBlockId);
    }
  }

  // Track which blocks are nested (so we skip them in main ordering)
  const nestedBlocks = new Set<string>();
  for (const [fromId, toIds] of nestingConnectionMap.entries()) {
    for (const toId of toIds) {
      nestedBlocks.add(toId);
    }
  }

  // Order blocks: follow visual order, but respect sequential connections only
  const ordered: PlacedBlock[] = [];
  const visited = new Set<string>();

  // Helper to add a block and its sequential connected chain
  function addBlockAndChain(block: PlacedBlock) {
    if (visited.has(block.id)) return;
    
    // Skip nested blocks - they will be processed when we're inside their parent
    // Don't mark them as visited here, so they can be processed inside their parent
    if (nestedBlocks.has(block.id)) {
      return;
    }
    
    visited.add(block.id);
    ordered.push(block);

    // Only follow SEQUENTIAL connections (not nesting connections)
    const connectedIds = sequentialConnectionMap.get(block.id) || [];
    const connectedBlocks = connectedIds
      .map(id => blockMap.get(id))
      .filter((b): b is PlacedBlock => b !== undefined)
      .filter(b => !nestedBlocks.has(b.id)) // Skip blocks that are nested in loops/conditionals
      .sort((a, b) => {
        if (a.y !== b.y) return a.y - b.y;
        return a.x - b.x;
      });

    for (const connectedBlock of connectedBlocks) {
      addBlockAndChain(connectedBlock);
    }
  }

  // Process blocks in visual order
  for (const block of sortedByY) {
    // Skip nested blocks entirely - they'll be processed inside their parent
    if (nestedBlocks.has(block.id)) {
      continue;
    }
    
    // Only process if it's a starting block (no incoming sequential connections) or hasn't been visited
    const hasIncoming = reverseMap.has(block.id);
    if (!hasIncoming || !visited.has(block.id)) {
      addBlockAndChain(block);
    }
  }

  // Add any remaining unvisited blocks that aren't nested (shouldn't happen, but safety check)
  for (const block of sortedByY) {
    if (!visited.has(block.id) && !nestedBlocks.has(block.id)) {
      ordered.push(block);
    }
  }

  return ordered;
}

/**
 * Generate Arduino code from a block
 */
function generateFromBlock(
  block: PlacedBlock,
  allBlocks: PlacedBlock[],
  connections: BlockConnection[],
  visited: Set<string>,
  globalLines: string[],
  setupLines: string[],
  loopLines: string[],
  usedPins: Set<number>,
  addedSetupCode: Set<string>,
  addedGlobalCode: Set<string>,
  indent: number,
  isNested: boolean = false
): void {
  // For top-level blocks, prevent infinite loops
  if (!isNested && visited.has(block.id)) {
    return; // Prevent infinite loops
  }
  
  // Mark as visited (for both nested and top-level to prevent duplicate processing)
  visited.add(block.id);

  const schemaBlock = getBlockSchema(block.blockId);
  if (!schemaBlock) {
    return;
  }

  const values = block.fieldValues;
  const indentStr = "  ".repeat(indent);

  // Generate Arduino code based on block type
  const arduinoCode = generateBlockArduinoCode(
    block.blockId,
    values,
    schemaBlock,
    usedPins,
    addedSetupCode,
    addedGlobalCode
  );

  if (arduinoCode.global) {
    for (const line of arduinoCode.global) {
      if (!addedGlobalCode.has(line)) {
        addedGlobalCode.add(line);
        globalLines.push(line);
      }
    }
  }

  if (arduinoCode.setup) {
    for (const line of arduinoCode.setup) {
      const fullLine = indentStr + line;
      if (!addedSetupCode.has(line)) {
        addedSetupCode.add(line);
        setupLines.push(line);
      }
    }
  }

  if (arduinoCode.loop) {
    for (const line of arduinoCode.loop) {
      loopLines.push(indentStr + line);
    }
  }

  // Handle nested blocks (loops, conditionals)
  if (shouldNestContent(block.blockId)) {
    // Find nested blocks (blocks connected to this one) - sorted by Y position for consistent order
    const nestedBlocks = allBlocks.filter(b => {
      return connections.some(c => 
        c.fromBlockId === block.id && c.toBlockId === b.id
      );
    }).sort((a, b) => {
      // Sort by Y position (top to bottom), then X (left to right)
      if (a.y !== b.y) return a.y - b.y;
      return a.x - b.x;
    });

    for (const nestedBlock of nestedBlocks) {
      // Process nested blocks - pass isNested=true to allow processing even if visited
      generateFromBlock(
        nestedBlock,
        allBlocks,
        connections,
        visited,
        globalLines,
        setupLines,
        loopLines,
        usedPins,
        addedSetupCode,
        addedGlobalCode,
        indent + 1,
        true // isNested = true
      );
    }
    
    // Add closing brace for loop/conditional
    loopLines.push(indentStr + "}");
  }
  // Note: Sequential blocks are handled by the visual ordering function,
  // so we don't need to recursively follow connections here
}

/**
 * Generate Arduino code for a specific block
 */
function generateBlockArduinoCode(
  blockId: string,
  values: Record<string, any>,
  schemaBlock: any,
  usedPins: Set<number>,
  addedSetupCode: Set<string>,
  addedGlobalCode: Set<string>
): { global?: string[]; setup?: string[]; loop?: string[] } {
  const pin = values.pin ?? schemaBlock.fields?.pin?.default ?? 13;

  switch (blockId) {
    // General blocks
    case 'print': {
      const text = values.text || schemaBlock.fields?.text?.default || "Hello";
      const setupLine = "Serial.begin(9600);";
      const result: { global?: string[]; setup?: string[]; loop?: string[] } = {
        loop: [`Serial.println("${text}");`],
      };
      if (!addedSetupCode.has(setupLine)) {
        addedSetupCode.add(setupLine);
        result.setup = [setupLine];
      }
      return result;
    }

    case 'variable': {
      const varName = values.variable || schemaBlock.fields?.variable?.default || "x";
      const varValue = values.value ?? schemaBlock.fields?.value?.default ?? 0;
      return {
        global: [`int ${varName} = ${varValue};`],
      };
    }

    case 'sleep': {
      const seconds = values.seconds ?? schemaBlock.fields?.seconds?.default ?? 1;
      const ms = seconds * 1000;
      return {
        loop: [`delay(${ms});`],
      };
    }

    case 'delay': {
      const ms = values.milliseconds ?? schemaBlock.fields?.milliseconds?.default ?? 1000;
      return {
        loop: [`delay(${ms});`],
      };
    }

    // Loop blocks
    case 'forever_loop':
      return {
        loop: [`// Forever loop`],
      };

    case 'repeat': {
      const times = values.times || schemaBlock.fields?.times?.default || 1;
      return {
        loop: [`for (int i = 0; i < ${times}; i++) {`],
      };
    }

    case 'for_loop': {
      const varName = values.variable || schemaBlock.fields?.variable?.default || "i";
      const range = values.range || schemaBlock.fields?.range?.default || "range(10)";
      // Parse range(10) -> 10
      const match = range.match(/range\((\d+)\)/);
      const max = match ? match[1] : 10;
      return {
        loop: [`for (int ${varName} = 0; ${varName} < ${max}; ${varName}++) {`],
      };
    }

    case 'while_loop': {
      const condition = values.condition || schemaBlock.fields?.condition?.default || "true";
      return {
        loop: [`while (${condition}) {`],
      };
    }

    case 'break':
      return {
        loop: [`break;`],
      };

    // Condition blocks
    case 'if_else': {
      const left = values.left || "";
      const op = values.operator || schemaBlock.fields?.operator?.default || ">=";
      const right = values.right || "";
      return {
        loop: [`if (${left} ${op} ${right}) {`],
      };
    }

    // GPIO blocks
    case 'gpio_pin': {
      const mode = values.mode || schemaBlock.fields?.mode?.default || "OUT";
      const pinModeStr = mode === "OUT" ? "OUTPUT" : "INPUT";
      if (!usedPins.has(pin)) {
        usedPins.add(pin);
        return {
          setup: [`pinMode(${pin}, ${pinModeStr});`],
        };
      }
      return {};
    }

    case 'pin_write': {
      const value = values.value ?? schemaBlock.fields?.value?.default ?? true;
      const arduinoValue = value ? "HIGH" : "LOW";
      const setupLine = `pinMode(${pin}, OUTPUT);`;
      if (!addedSetupCode.has(setupLine) && !usedPins.has(pin)) {
        usedPins.add(pin);
        addedSetupCode.add(setupLine);
        return {
          setup: [setupLine],
          loop: [`digitalWrite(${pin}, ${arduinoValue});`],
        };
      }
      return {
        loop: [`digitalWrite(${pin}, ${arduinoValue});`],
      };
    }

    case 'digitalwrite': {
      const value = values.value ?? schemaBlock.fields?.value?.default ?? "HIGH";
      const setupLine = `pinMode(${pin}, OUTPUT);`;
      if (!addedSetupCode.has(setupLine) && !usedPins.has(pin)) {
        usedPins.add(pin);
        addedSetupCode.add(setupLine);
        return {
          setup: [setupLine],
          loop: [`digitalWrite(${pin}, ${value});`],
        };
      }
      return {
        loop: [`digitalWrite(${pin}, ${value});`],
      };
    }

    case 'pin_read': {
      const store = values.store || schemaBlock.fields?.store?.default || "value";
      const pull = values.pull || schemaBlock.fields?.pull?.default || "Pin.PULL_DOWN";
      const pullMode = pull.includes("PULL_UP") ? "INPUT_PULLUP" : "INPUT";
      const setupLine = `pinMode(${pin}, ${pullMode});`;
      if (!addedSetupCode.has(setupLine) && !usedPins.has(pin)) {
        usedPins.add(pin);
        addedSetupCode.add(setupLine);
        return {
          global: [`int ${store} = 0;`],
          setup: [setupLine],
          loop: [`${store} = digitalRead(${pin});`],
        };
      }
      return {
        global: [`int ${store} = 0;`],
        loop: [`${store} = digitalRead(${pin});`],
      };
    }

    case 'pwm': {
      const freq = values.frequency ?? schemaBlock.fields?.frequency?.default ?? 1000;
      const duty = values.duty_cycle ?? schemaBlock.fields?.duty_cycle?.default ?? 512;
      const setupLine = `pinMode(${pin}, OUTPUT);`;
      if (!addedSetupCode.has(setupLine) && !usedPins.has(pin)) {
        usedPins.add(pin);
        addedSetupCode.add(setupLine);
        return {
          global: [`int pwm_${pin} = 0;`],
          setup: [setupLine],
          loop: [`analogWrite(${pin}, ${duty});`],
        };
      }
      return {
        loop: [`analogWrite(${pin}, ${duty});`],
      };
    }

    case 'adc': {
      const store = values.store || schemaBlock.fields?.store?.default || "value";
      return {
        global: [`int ${store} = 0;`],
        loop: [`${store} = analogRead(${pin});`],
      };
    }

    case 'neopixel_led': {
      const index = values.led_index ?? schemaBlock.fields?.led_index?.default ?? 0;
      const color = values.color || schemaBlock.fields?.color?.default || "#FF0000";
      const r = parseInt(color.slice(1, 3), 16);
      const g = parseInt(color.slice(3, 5), 16);
      const b = parseInt(color.slice(5, 7), 16);
      return {
        global: [
          `// NeoPixel library would need to be included`,
          `// #include <Adafruit_NeoPixel.h>`,
          `// Adafruit_NeoPixel strip = Adafruit_NeoPixel(8, ${pin}, NEO_GRB + NEO_KHZ800);`,
        ],
        setup: [
          `// strip.begin();`,
          `// strip.setPixelColor(${index}, strip.Color(${r}, ${g}, ${b}));`,
          `// strip.show();`,
        ],
        loop: [
          `// NeoPixel control code (requires library)`,
        ],
      };
    }

    case 'buzzer_tone': {
      const toneFreq = values.tone ?? schemaBlock.fields?.tone?.default ?? 1000;
      return {
        loop: [
          `tone(${pin}, ${toneFreq});`,
        ],
      };
    }

    // Sensor blocks
    case 'ultrasonic_sensor': {
      const trigger = values.trigger_pin ?? schemaBlock.fields?.trigger_pin?.default ?? 1;
      const echo = values.echo_pin ?? schemaBlock.fields?.echo_pin?.default ?? 5;
      const store = values.store || schemaBlock.fields?.store?.default || "distance";
      return {
        global: [
          `long ${store} = 0;`,
          `// Ultrasonic sensor requires custom library or manual implementation`,
        ],
        setup: [
          `pinMode(${trigger}, OUTPUT);`,
          `pinMode(${echo}, INPUT);`,
        ],
        loop: [
          `// ${store} = readUltrasonic(${trigger}, ${echo});`,
        ],
      };
    }

    case 'dht11_sensor': {
      const dataPin = values.data_pin ?? schemaBlock.fields?.data_pin?.default ?? 4;
      const tempVar = values.temperature || schemaBlock.fields?.temperature?.default || "temperature";
      const humVar = values.humidity || schemaBlock.fields?.humidity?.default || "humidity";
      return {
        global: [
          `float ${tempVar} = 0;`,
          `float ${humVar} = 0;`,
          `// DHT11 requires DHT library`,
          `// #include <DHT.h>`,
          `// DHT dht(${dataPin}, DHT11);`,
        ],
        setup: [
          `// dht.begin();`,
        ],
        loop: [
          `// ${tempVar} = dht.readTemperature();`,
          `// ${humVar} = dht.readHumidity();`,
        ],
      };
    }

    case 'ir_sensor': {
      const dataPin = values.data_pin ?? schemaBlock.fields?.data_pin?.default ?? 4;
      const store = values.store || schemaBlock.fields?.store?.default || "ir_value";
      const setupLine = `pinMode(${dataPin}, INPUT);`;
      if (!addedSetupCode.has(setupLine)) {
        addedSetupCode.add(setupLine);
        return {
          global: [`int ${store} = 0;`],
          setup: [setupLine],
          loop: [`${store} = digitalRead(${dataPin});`],
        };
      }
      return {
        global: [`int ${store} = 0;`],
        loop: [`${store} = digitalRead(${dataPin});`],
      };
    }

    // Motor blocks
    case 'l298_motor': {
      const in1 = values.in1_pin ?? schemaBlock.fields?.in1_pin?.default ?? 12;
      const in2 = values.in2_pin ?? schemaBlock.fields?.in2_pin?.default ?? 14;
      const in3 = values.in3_pin ?? schemaBlock.fields?.in3_pin?.default ?? 27;
      const in4 = values.in4_pin ?? schemaBlock.fields?.in4_pin?.default ?? 26;
      const direction = values.direction || schemaBlock.fields?.direction?.default || "Forward";
      const setupLines: string[] = [];
      const loopLines: string[] = [];
      
      if (!usedPins.has(in1)) {
        usedPins.add(in1);
        setupLines.push(`pinMode(${in1}, OUTPUT);`);
      }
      if (!usedPins.has(in2)) {
        usedPins.add(in2);
        setupLines.push(`pinMode(${in2}, OUTPUT);`);
      }
      if (!usedPins.has(in3)) {
        usedPins.add(in3);
        setupLines.push(`pinMode(${in3}, OUTPUT);`);
      }
      if (!usedPins.has(in4)) {
        usedPins.add(in4);
        setupLines.push(`pinMode(${in4}, OUTPUT);`);
      }
      
      if (direction === "Forward") {
        loopLines.push(`digitalWrite(${in1}, HIGH);`);
        loopLines.push(`digitalWrite(${in2}, LOW);`);
        loopLines.push(`digitalWrite(${in3}, HIGH);`);
        loopLines.push(`digitalWrite(${in4}, LOW);`);
      } else {
        loopLines.push(`digitalWrite(${in1}, LOW);`);
        loopLines.push(`digitalWrite(${in2}, HIGH);`);
        loopLines.push(`digitalWrite(${in3}, LOW);`);
        loopLines.push(`digitalWrite(${in4}, HIGH);`);
      }
      
      return {
        setup: setupLines,
        loop: loopLines,
      };
    }

    case 'servo_motor': {
      const angle = values.angle ?? schemaBlock.fields?.angle?.default ?? 90;
      return {
        global: [
          `// Servo requires Servo library`,
          `// #include <Servo.h>`,
          `// Servo servo;`,
        ],
        setup: [
          `// servo.attach(${pin});`,
        ],
        loop: [
          `// servo.write(${angle});`,
        ],
      };
    }

    // Display blocks
    case 'oled_display': {
      const text = values.text || schemaBlock.fields?.text?.default || "Hello world";
      return {
        global: [
          `// OLED display requires U8g2lib or Adafruit_SSD1306 library`,
          `// #include <U8g2lib.h>`,
        ],
        setup: [
          `// display.begin();`,
        ],
        loop: [
          `// display.clearBuffer();`,
          `// display.setCursor(0, 0);`,
          `// display.print("${text}");`,
          `// display.sendBuffer();`,
        ],
      };
    }

    case 'graph':
    case 'play_animation':
    case 'show_image':
      return {
        loop: [`// ${schemaBlock.label || blockId} - Not implemented for Arduino`],
      };

    default:
      return {
        loop: [`// Block: ${schemaBlock.label || blockId}`],
      };
  }
}

/**
 * Check if a block should nest its content
 */
function shouldNestContent(blockId: string): boolean {
  return ['for_loop', 'while_loop', 'forever_loop', 'repeat', 'if_else'].includes(blockId);
}

/**
 * Get block schema from schemaData
 */
function getBlockSchema(blockId: string): any {
  for (const category of schemaData.categories) {
    const block = category.components.find(c => c.id === blockId);
    if (block) return block;
  }
  return null;
}

